package handles

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"log"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	libutils "github.com/opensourceways/server-common-lib/utils"
	"github.com/robfig/cron/v3"

	"cve-sa-backend/handles/manage"
	"cve-sa-backend/iniconf"
	"cve-sa-backend/utils"
)

const (
	pkgUrl = "https://mirrors.nju.edu.cn/openeuler/%s/update/%s/Packages/%s"
	size   = 50
)

var num = regexp.MustCompile(`\d+`)

func Task(c *cron.Cron) error {
	//updateinfoId, err := c.AddFunc("0 0 0 * * 0", syncFullUpdateinfo)
	//if err != nil {
	//	return err
	//}
	//log.Printf("register updateinfo task %d", updateinfoId)
	//
	//newUpdateinfoId, err := c.AddFunc("0 0 0 * * 1,5,6", syncLatestUpdateinfo)
	//if err != nil {
	//	return err
	//}
	//log.Printf("register newupdateinfo task %d", newUpdateinfoId)

	syncHardwareId, err := c.AddFunc("0 0 * * * *", syncHardware)
	if err != nil {
		return err
	}
	log.Printf("sync hardware task %d", syncHardwareId)

	syncDriverId, err := c.AddFunc("0 1 * * * *", syncDriver)
	if err != nil {
		return err
	}
	log.Printf("sync driver task %d", syncDriverId)

	syncOsvId, err := c.AddFunc("0 2 */2 * * *", syncOsv)
	if err != nil {
		return err
	}
	log.Printf("sync osv task %d", syncOsvId)

	syncSolutionId, err := c.AddFunc("0 3 */4 * * *", syncSolution)
	if err != nil {
		return err
	}
	log.Printf("sync solution task %d", syncSolutionId)

	return nil
}

func syncFullUpdateinfo() {
	log.Println("task updateinfo start")
	cfg, err := iniconf.Cfg.GetSection("cve")
	if err != nil {
		iniconf.SLog.Errorf("get conf failed, err: %s", err.Error())

		return
	}

	var wg sync.WaitGroup

	f := func(b string) {
		defer wg.Done()
		var bys []byte
		updateInfoPath := iniconf.Obs.DownloadUpdateinfo + b + "/updateinfo.xml"

		bys, err = utils.DownloadFile(updateInfoPath)
		if err != nil {
			iniconf.SLog.Errorf("download %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}
		var v utils.Updates
		err = xml.Unmarshal(bys, &v)
		if err != nil {
			iniconf.SLog.Errorf("xml unmarshal %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}

		l := len(v.Updatex)
		number := l / size
		if l%size != 0 {
			number++
		}

		var w sync.WaitGroup
		ff := func(update []utils.Update, v int) {
			defer w.Done()
			for i := range update {
				u := &update[i]
				for j := range u.Pkglist.Collection.Package {
					p := &u.Pkglist.Collection.Package[j]
					if len(p.Epoch) > 0 {
						continue
					}
					epoch, err := findEpoch(cfg.Key("script").String(), b, p.Filename, p.Arch, v)
					if err == nil && len(epoch) > 0 {
						p.Epoch = string(epoch)
					}
				}
			}
		}

		for i := 0; i < number; i++ {
			start := i * size
			end := (i + 1) * size
			if end > l {
				end = l
			}
			w.Add(1)
			go ff(v.Updatex[start:end], i)
		}

		w.Wait()

		bys, err = v.UpdatesData()
		if err != nil {
			iniconf.SLog.Errorf("xml marshal %s updateinfo.xml failed, err:%s", b, err.Error())

			return
		}

		err = utils.UploadFile(updateInfoPath, bytes.NewReader(bys))
		if err != nil {
			iniconf.SLog.Errorf("upload file failed, err:%s", err.Error())
		}

		log.Printf("task updateinfo branch:%s end\n", b)
	}

	for _, s := range strings.Split(cfg.Key("branch").String(), ",") {
		wg.Add(1)
		log.Printf("start branch: %s\n", s)
		go f(s)
	}

	wg.Wait()

	log.Println("task updateinfo end")
}

func syncLatestUpdateinfo() {
	log.Println("task updateinfo start")
	cfg, err := iniconf.Cfg.GetSection("cve")
	if err != nil {
		iniconf.SLog.Errorf("get conf failed, err: %s", err.Error())

		return
	}

	var wg sync.WaitGroup

	f := func(b string) {
		defer wg.Done()
		var bys []byte
		updateInfoPath := iniconf.Obs.DownloadUpdateinfo + b + "/updateinfo.xml"

		bys, err = utils.DownloadFile(updateInfoPath)
		if err != nil {
			iniconf.SLog.Errorf("download %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}
		var v utils.Updates
		err = xml.Unmarshal(bys, &v)
		if err != nil {
			iniconf.SLog.Errorf("xml unmarshal %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}

		sort.Slice(v.Updatex, func(i, j int) bool {
			return v.Updatex[i].Id > v.Updatex[j].Id
		})

		ff := func(update []utils.Update, v int) {
			for i := range update {
				u := &update[i]
				for j := range u.Pkglist.Collection.Package {
					p := &u.Pkglist.Collection.Package[j]
					if len(p.Epoch) > 0 || strings.Contains(p.Filename, "kernel") {
						continue
					}

					epoch, err := findEpoch(cfg.Key("script").String(), b, p.Filename, p.Arch, v)
					if err == nil && len(epoch) > 0 {
						p.Epoch = string(epoch)
					}
				}
			}
		}

		if len(v.Updatex) < size {
			ff(v.Updatex, 1)
		} else {
			ff(v.Updatex[0:size], 1)
		}

		sort.Slice(v.Updatex, func(i, j int) bool {
			return v.Updatex[i].Id < v.Updatex[j].Id
		})

		bys, err = v.UpdatesData()
		if err != nil {
			iniconf.SLog.Errorf("xml marshal %s updateinfo.xml failed, err:%s", b, err.Error())

			return
		}

		err = utils.UploadFile(updateInfoPath, bytes.NewReader(bys))
		if err != nil {
			iniconf.SLog.Errorf("upload file failed, err:%s", err.Error())
		}

		log.Printf("task updateinfo branch:%s end\n", b)
	}

	for _, s := range strings.Split(cfg.Key("branch").String(), ",") {
		wg.Add(1)
		log.Printf("start branch: %s\n", s)
		go f(s)
	}

	wg.Wait()

	log.Println("task updateinfo end")
}

func findEpoch(script, branch, filename, arch string, i int) ([]byte, error) {
	var archs = []string{arch}
	if arch == "noarch" {
		archs = []string{"aarch64", "x86_64"}
	}
	for _, a := range archs {
		epoch, err, _ := libutils.RunCmd(
			script,
			filepath.Join("/opt/app/", branch, strconv.Itoa(i), time.Now().Format("150405.999")),
			fmt.Sprintf(pkgUrl, branch, a, filename),
		)

		if err != nil {
			fmt.Println(fmt.Sprintf(pkgUrl, branch, a, filename))
		}

		if err == nil {
			if strings.Contains(string(epoch), "404") {
				continue
			}
			if ix := bytes.Index(epoch, []byte("NOKEY")); ix > 0 {
				epoch = bytes.TrimSpace(epoch[ix+5:])
			} else {
				epoch = bytes.TrimSpace(epoch)
			}

			return num.Find(epoch), nil
		}
	}

	return nil, nil
}

func syncHardware() {
	result, err := manage.SyncHardwareCompatibility()
	if err != nil {
		iniconf.SLog.Error("syncHardwareCompatibility failed :", err)

		return
	}

	log.Println("syncHardwareCompatibility: ", result)
}

func syncDriver() {
	result, err := manage.SyncDriverCompatibility()
	if err != nil {
		iniconf.SLog.Error("syncDriverCompatibility failed :", err)

		return
	}

	log.Println("syncDriverCompatibility: ", result)
}

func syncOsv() {
	result, err := manage.SyncOsv()
	if err != nil {
		iniconf.SLog.Error("syncOsv failed :", err)

		return
	}

	log.Println("syncOsv: ", result)
}

func syncSolution() {
	result, err := manage.SyncSolutionCompatibility()
	if err != nil {
		iniconf.SLog.Error("SyncSolutionCompatibility failed :", err)

		return
	}

	log.Println("syncSolutionCompatibility: ", result)
}

