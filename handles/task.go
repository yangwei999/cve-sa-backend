package handles

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	libutils "github.com/opensourceways/server-common-lib/utils"
	"github.com/robfig/cron/v3"

	"cve-sa-backend/iniconf"
	"cve-sa-backend/utils"
)

const (
	pkgUrl = "https://mirrors.nju.edu.cn/openeuler/%s/update/%s/Packages/%s"
	size   = 50
)

var num = regexp.MustCompile(`\d+`)

func Task(c *cron.Cron) error {
	osvId, err := c.AddFunc("0 0 9 * * *", taskOsv)
	if err != nil {
		return err
	}
	log.Printf("register osv task %d", osvId)

	hardwareId, err := c.AddFunc("0 30 9 * * *", taskHardware)
	if err != nil {
		return err
	}
	log.Printf("register hardware task %d", hardwareId)

	updateinfoId, err := c.AddFunc("0 0 10 * * 0", syncFullUpdateinfo)
	if err != nil {
		return err
	}
	log.Printf("register updateinfo task %d", updateinfoId)

	newUpdateinfoId, err := c.AddFunc("0 0 10 * * 1,2,3,4,5,6", syncLatestUpdateinfo)
	if err != nil {
		return err
	}
	log.Printf("register newupdateinfo task %d", newUpdateinfoId)

	//driverId, err := c.AddFunc("0 0 1 * * *", taskDriver)
	//if err != nil {
	//	return err
	//}
	//log.Printf("register driver task %d", driverId)

	return nil
}

func taskOsv() {
	log.Println("start osv")
	defer log.Println("end osv")

	url := "https://cvesa.test.osinfra.cn/cve-security-notice-server/syncOsv"
	var buf = new(bytes.Buffer)
	form := multipart.NewWriter(buf)
	_ = form.WriteField("username", iniconf.Upload.Username)
	_ = form.WriteField("password", iniconf.Upload.Password)
	err := form.Close()
	if err != nil {
		iniconf.SLog.Errorf("multipart close failed, err: %s", err.Error())
		return
	}

	var resp *http.Response
	resp, err = http.Post(url, form.FormDataContentType(), buf)
	if err != nil {
		iniconf.SLog.Errorf("http failed, url:%s err: %s", url, err.Error())
		return
	}

	if resp.StatusCode != http.StatusOK {
		iniconf.SLog.Errorf("request osv failed, status: %d, msg: %s", resp.StatusCode, resp.Status)
		return
	}
}

func taskHardware() {
	log.Println("start hardware")
	defer log.Println("end hardware")

	url := "https://cvesa.test.osinfra.cn/cve-security-notice-server/syncHardware"
	var buf = new(bytes.Buffer)
	form := multipart.NewWriter(buf)
	_ = form.WriteField("username", iniconf.Upload.Username)
	_ = form.WriteField("password", iniconf.Upload.Password)
	err := form.Close()
	if err != nil {
		iniconf.SLog.Errorf("multipart close failed, err: %s", err.Error())
		return
	}

	var resp *http.Response
	resp, err = http.Post(url, form.FormDataContentType(), buf)
	if err != nil {
		iniconf.SLog.Errorf("http failed, url:%s err: %s", url, err.Error())
		return
	}

	if resp.StatusCode != http.StatusOK {
		iniconf.SLog.Errorf("request hardware failed, status: %d, msg: %s", resp.StatusCode, resp.Status)
		return
	}
}

func taskDriver() {
	log.Println("start driver")
	defer log.Println("end driver")

	url := "https://cvesa.test.osinfra.cn/cve-security-notice-server/syncDriver"
	var buf = new(bytes.Buffer)
	form := multipart.NewWriter(buf)
	_ = form.WriteField("username", iniconf.Upload.Username)
	_ = form.WriteField("password", iniconf.Upload.Password)

	err := form.Close()
	if err != nil {
		iniconf.SLog.Errorf("multipart close failed, err: %s", err.Error())
		return
	}

	var resp *http.Response
	resp, err = http.Post(url, form.FormDataContentType(), buf)
	if err != nil {
		iniconf.SLog.Errorf("http failed, url:%s err: %s", url, err.Error())
		return
	}

	if resp.StatusCode != http.StatusOK {
		iniconf.SLog.Errorf("request driver failed, status: %d, msg: %s", resp.StatusCode, resp.Status)
		return
	}
}

func syncFullUpdateinfo() {
	log.Println("task updateinfo start")
	cfg, err := iniconf.Cfg.GetSection("cve")
	if err != nil {
		iniconf.SLog.Errorf("get conf failed, err: %s", err.Error())

		return
	}

	var wg sync.WaitGroup

	f := func(b string) {
		defer wg.Done()
		var bys []byte
		bys, err = utils.DownloadFile(fmt.Sprintf("updateinfo/%s/updateinfo.xml", b))
		if err != nil {
			iniconf.SLog.Errorf("download %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}
		var v utils.Updates
		err = xml.Unmarshal(bys, &v)
		if err != nil {
			iniconf.SLog.Errorf("xml unmarshal %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}

		l := len(v.Updatex)
		number := l / size
		if l%size != 0 {
			number++
		}

		var w sync.WaitGroup
		ff := func(update []utils.Update, v int) {
			defer w.Done()
			for i := range update {
				u := &update[i]
				for j := range u.Pkglist.Collection.Package {
					p := &u.Pkglist.Collection.Package[j]
					if len(p.Epoch) > 0 {
						continue
					}
					epoch, err := findEpoch(cfg.Key("script").String(), b, p.Filename, p.Arch, v)
					if err == nil && len(epoch) > 0 {
						p.Epoch = string(epoch)
					}
				}
			}
		}

		for i := 0; i < number; i++ {
			start := i * size
			end := (i + 1) * size
			if end > l {
				end = l
			}
			w.Add(1)
			go ff(v.Updatex[start:end], i)
		}

		w.Wait()

		bys, err = v.UpdatesData()
		if err != nil {
			iniconf.SLog.Errorf("xml marshal %s updateinfo.xml failed, err:%s", b, err.Error())

			return
		}

		err = utils.UploadFile("disclosure-cve/"+b+"/full-updateinfo.xml", bytes.NewReader(bys))
		if err != nil {
			iniconf.SLog.Errorf("upload file failed, err:%s", err.Error())
		}

		log.Printf("task updateinfo branch:%s end\n", b)
	}

	for _, s := range strings.Split(cfg.Key("branch").String(), ",") {
		wg.Add(1)
		log.Printf("start branch: %s\n", s)
		go f(s)
	}

	wg.Wait()

	log.Println("task updateinfo end")
}

func findEpoch(script, branch, filename, arch string, i int) ([]byte, error) {
	var archs = []string{arch}
	if arch == "noarch" {
		archs = []string{"aarch64", "x86_64"}
	}

	var x []string
	for _, a := range archs {
		epoch, err, _ := libutils.RunCmd(
			script,
			filepath.Join("/opt/app/", branch, strconv.Itoa(i), time.Now().Format("150405.999")),
			fmt.Sprintf(pkgUrl, branch, a, filename),
		)

		if err != nil {
			fmt.Println(fmt.Sprintf(pkgUrl, branch, a, filename))
		}

		if err == nil {
			if strings.Contains(string(epoch), "404") {
				x = append(x, fmt.Sprintf(pkgUrl, branch, a, filename))
				continue
			}
			if ix := bytes.Index(epoch, []byte("NOKEY")); ix > 0 {
				epoch = bytes.TrimSpace(epoch[ix+5:])
			} else {
				epoch = bytes.TrimSpace(epoch)
			}

			return num.Find(epoch), nil
		}
	}

	if len(x) != 0 {
		return []byte(strings.Join(x, ",")), errors.New("404")
	}

	return nil, nil
}

func syncLatestUpdateinfo() {
	log.Println("task updateinfo start")
	cfg, err := iniconf.Cfg.GetSection("cve")
	if err != nil {
		iniconf.SLog.Errorf("get conf failed, err: %s", err.Error())

		return
	}

	var wg sync.WaitGroup

	f := func(b string) {
		defer wg.Done()
		var bys []byte
		bys, err = utils.DownloadFile(fmt.Sprintf("updateinfo/%s/updateinfo.xml", b))
		if err != nil {
			iniconf.SLog.Errorf("download %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}
		var v utils.Updates
		err = xml.Unmarshal(bys, &v)
		if err != nil {
			iniconf.SLog.Errorf("xml unmarshal %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}

		sort.Slice(v.Updatex, func(i, j int) bool {
			return v.Updatex[i].Id > v.Updatex[j].Id
		})

		ff := func(update []utils.Update, v int) {
			for i := range update {
				u := &update[i]
				for j := range u.Pkglist.Collection.Package {
					p := &u.Pkglist.Collection.Package[j]
					if len(p.Epoch) > 0 || strings.Contains(p.Filename, "kernel") {
						continue
					}

					epoch, err := findEpoch(cfg.Key("script").String(), b, p.Filename, p.Arch, v)
					if err == nil && len(epoch) > 0 {
						p.Epoch = string(epoch)
					}
				}
			}
		}

		if len(v.Updatex) < size {
			ff(v.Updatex, 1)
		} else {
			ff(v.Updatex[0:size], 1)
		}

		sort.Slice(v.Updatex, func(i, j int) bool {
			return v.Updatex[i].Id < v.Updatex[j].Id
		})

		bys, err = v.UpdatesData()
		if err != nil {
			iniconf.SLog.Errorf("xml marshal %s updateinfo.xml failed, err:%s", b, err.Error())

			return
		}

		err = utils.UploadFile("disclosure-cve/"+b+"/latest-updateinfo.xml", bytes.NewReader(bys))
		if err != nil {
			iniconf.SLog.Errorf("upload file failed, err:%s", err.Error())
		}

		log.Printf("task updateinfo branch:%s end\n", b)
	}

	for _, s := range strings.Split(cfg.Key("branch").String(), ",") {
		wg.Add(1)
		log.Printf("start branch: %s\n", s)
		go f(s)
	}

	wg.Wait()

	log.Println("task updateinfo end")
}

type file404 struct {
	SA      string   `json:"sa"`
	Package []string `json:"package"`
}

func find404() {
	log.Println("task updateinfo start")
	cfg, err := iniconf.Cfg.GetSection("cve")
	if err != nil {
		iniconf.SLog.Errorf("get conf failed, err: %s", err.Error())

		return
	}

	var wg sync.WaitGroup

	f := func(b string) {
		defer wg.Done()
		var bys []byte
		bys, err = utils.DownloadFile(fmt.Sprintf("updateinfo/%s/updateinfo.xml", b))
		if err != nil {
			iniconf.SLog.Errorf("download %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}
		var v utils.Updates
		err = xml.Unmarshal(bys, &v)
		if err != nil {
			iniconf.SLog.Errorf("xml unmarshal %s updateinfo.yaml failed, err:%s", b, err.Error())

			return
		}

		sort.Slice(v.Updatex, func(i, j int) bool {
			return v.Updatex[i].Id > v.Updatex[j].Id
		})

		var fi []file404

		ff := func(update []utils.Update, v int) {
			for i := range update {
				u := &update[i]
				var f file404
				f.SA = u.Id
				for j := range u.Pkglist.Collection.Package {
					p := &u.Pkglist.Collection.Package[j]
					//if len(p.Epoch) > 0 || strings.Contains(p.Filename, "kernel") {
					//	continue
					//}

					epoch, err := findEpoch(cfg.Key("script").String(), b, p.Filename, p.Arch, v)
					if err != nil && err.Error() == "404" {
						f.Package = append(f.Package, strings.Split(string(epoch), ",")...)
					}
				}

				fi = append(fi, f)
			}
		}

		if len(v.Updatex) < size {
			ff(v.Updatex, 1)
		} else {
			ff(v.Updatex[0:size], 1)
		}

		marshal, _ := json.Marshal(fi)

		os.WriteFile(b+".json", marshal, 0777)

		log.Printf("task updateinfo branch:%s end\n", b)
	}

	for _, s := range strings.Split(cfg.Key("branch").String(), ",") {
		wg.Add(1)
		log.Printf("start branch: %s\n", s)
		go f(s)
	}

	wg.Wait()

	log.Println("task updateinfo end")
}
