package web

import (
	"sort"
	"strings"

	"k8s.io/kube-openapi/pkg/util/sets"

	"cve-sa-backend/dao"
	"cve-sa-backend/models"
	_const "cve-sa-backend/utils/const"
	"cve-sa-backend/utils/entity/cve_sa"
)

var productName = []string{"src", "aarch64", "noarch", "x86_64"}

func FindAllSecurity(req cvesa.RequestNotice) (*cvesa.ResultData, error) {
	datas, total, err := dao.DefaultSecurityNotice.SecurityFindAll(req)
	if err != nil {
		return nil, err
	}
	return returnNoticeData(datas, total), nil
}

func returnNoticeData(datas []models.CveSecurityNotice, total int64) *cvesa.ResultData {
	securityNoticeData := SecurityNoticeData(datas)
	return &cvesa.ResultData{
		SecurityNoticeList:  securityNoticeData,
		CveDatabaseList:     make([]cvesa.DatabaseData, 0),
		ApplicationCompList: make([]models.ROeCompatibilityApplication, 0),
		HardwareCompList:    make([]cvesa.HardwareCompatibility, 0),
		DriverCompList:      make([]models.OeCompatibilityDriver, 0),
		Total:               int(total),
	}
}

func GetSecurityNoticePackageByPackageName(pname string) ([]models.RCveSecurityNoticePackage, error) {
	pname = strings.Replace(pname, "\n", "", -1)
	pnames := strings.Split(pname, ",")

	datas, err := dao.DefaultSecurityNoticePackage.ByPackageName(pnames)
	if err != nil {
		return nil, err
	}
	return packageData(datas), nil
}

func packageData(datas []models.CveSecurityNoticePackage) []models.RCveSecurityNoticePackage {
	var list = make([]models.RCveSecurityNoticePackage, 0, len(datas))
	for _, v := range datas {
		list = append(list, models.RCveSecurityNoticePackage{CveSecurityNoticePackage: v, Updateime: v.Updateime.Format(_const.Format)})
	}
	return list
}

func NoticeByCVEID(cveId string) ([]cvesa.SecurityNoticeData, error) {
	datas, err := dao.DefaultSecurityNotice.NoticeByCveId(cveId)
	if err != nil {
		return nil, err
	}
	return SecurityNoticeData(datas), nil
}

func SecurityNoticeData(datas []models.CveSecurityNotice) []cvesa.SecurityNoticeData {
	var securityNoticeData = make([]cvesa.SecurityNoticeData, 0, len(datas))

	for _, v := range datas {
		securityNoticeData = append(securityNoticeData, SecurityNoticeDataOne(v))
	}
	return securityNoticeData
}

func SecurityNoticeDataOne(datas models.CveSecurityNotice) cvesa.SecurityNoticeData {
	return cvesa.SecurityNoticeData{
		RCveSecurityNotice: models.RCveSecurityNotice{
			CveSecurityNotice: datas,
			Updateime:         datas.Updateime.Format(_const.Format),
		},
		PackageHelperList: make([]cvesa.SAPackageHelper, 0),
		PackageList:       make([]models.RCveSecurityNoticePackage, 0),
		ReferenceList:     make([]models.RCveSecurityNoticeReference, 0),
		CveList:           make([]cvesa.DatabaseData, 0),
	}
}

func ByCveIdAndAffectedComponent(cveId, affectedComponent string) ([]cvesa.SecurityNoticeData, error) {
	datas, err := dao.DefaultSecurityNotice.NoticeByCveIdComponent(cveId, affectedComponent)
	if err != nil {
		return nil, err
	}
	return SecurityNoticeData(datas), nil
}

func NoticeBySecurityNoticeNo(s string) (*cvesa.SecurityNoticeData, error) {
	var SAPackages = make([]cvesa.SAPackageHelper, 0)
	securityNotice, err := dao.DefaultSecurityNotice.NoticeByNo(s)
	if err != nil {
		return nil, err
	}
	if securityNotice == nil {
		return nil, nil
	}
	snData := SecurityNoticeDataOne(*securityNotice)
	if securityNotice.AffectedProduct != "" {
		products := strings.Split(securityNotice.AffectedProduct, ";")
		for _, v := range products {
			packages, err := dao.DefaultSecurityNoticePackage.NoticePackageByNoProduct(s, v, models.TypeColdPatch)
			if err != nil {
				return &snData, nil
			}
			if len(packages) != 0 {
				var SAPackage cvesa.SAPackageHelper
				SAPackage.ProductName = v
				SAPackage.Child = getSAPackageHelper(packages)
				SAPackages = append(SAPackages, SAPackage)
			}
		}
	}
	snData.PackageHelperList = SAPackages
	snData.Description = strings.Replace(snData.Description, "\\r\\n", "\r\n", -1)
	snData.Subject = strings.Replace(snData.Subject, "\\r\\n", "\r\n", -1)

	snData.PackageHotpatchList = genHotPatchList(snData.SecurityNoticeNo)

	if references, err := dao.DefaultSecurityNoticeReference.GetReferenceByNo(s); err == nil {
		snData.ReferenceList = reReference(references)
	}

	relateDefectAndCve(&snData)

	return &snData, nil
}

func genHotPatchList(securityNumber string) []cvesa.HotPatchList {
	packages, _ := dao.DefaultSecurityNoticePackage.NoticePackageByNoProduct(securityNumber, "", models.TypeHotPatch)
	if len(packages) == 0 {
		return nil
	}

	temp := make(map[string]map[string][]string)
	for _, v := range packages {
		if _, ok := temp[v.ProductName]; ok {
			temp[v.ProductName][v.PackageType] = append(temp[v.ProductName][v.PackageType], v.PackageName)
		} else {
			temp[v.ProductName] = map[string][]string{
				v.PackageType: {v.PackageName},
			}
		}
	}

	var ret []cvesa.HotPatchList
	for product, v := range temp {
		var child []cvesa.HotPatchListCve
		for arch, rpms := range v {
			child = append(child, cvesa.HotPatchListCve{
				PackageType: arch,
				PackageName: rpms,
			})
		}

		data := cvesa.HotPatchList{
			ProductName: product,
			Child:       child,
		}

		ret = append(ret, data)
	}

	return ret
}

// If both the cve and the defect are repaired,
// the associated cve is displayed on the defect notice page
// the affected branches of defect and cves must be the same
func relateDefectAndCve(snData *cvesa.SecurityNoticeData) {
	if snData.IsCveNotice() {
		return
	}

	if len(snData.PackageHelperList) == 0 || len(snData.PackageHelperList[0].Child) == 0 {
		return
	}

	// packageName: wireshark-devel-3.6.14-2.oe1.x86_64.rpm, need:3.6.14-2.oe1
	packageName := snData.PackageHelperList[0].Child[0].Child[0].PackageName
	split := strings.Split(packageName, ".")
	t := strings.Join(split[0:len(split)-2], ".")
	split2 := strings.Split(t, "-")
	need := strings.Join(split2[len(split2)-2:], "-")

	securityNoticePackage, err := dao.DefaultSecurityNoticePackage.SearchPackageByVersion(need, snData.SecurityNoticeNo)
	if err != nil {
		return
	}

	notice, _ := dao.DefaultSecurityNotice.NoticeByNo(securityNoticePackage.SecurityNoticeNo)
	if notice == nil {
		return
	}

	snData.CveId += notice.CveId
}

func findProductNameIndex(v []cvesa.HotPatchList, name string) int {
	for i := range v {
		if v[i].ProductName == name {
			return i
		}
	}

	return -1
}

func findArchIndex(v []cvesa.HotPatchListCve, arch string) int {
	for i := range v {
		if v[i].PackageType == arch {
			return i
		}
	}

	return -1
}

func getSAPackageHelper(datas []models.CveSecurityNoticePackage) []cvesa.SAPackageHelper {
	var SAPackageMap = make(map[string][]cvesa.SAPackageHelper)
	var SAPackages = make([]cvesa.SAPackageHelper, 0)
	if len(datas) > 0 {
		for _, v := range datas {
			list, ok := SAPackageMap[v.PackageType]
			if !ok {
				list = make([]cvesa.SAPackageHelper, 0)
			}
			var helper cvesa.SAPackageHelper
			helper.PackageName = v.PackageName
			helper.Child = make([]cvesa.SAPackageHelper, 0)
			list = append(list, helper)
			SAPackageMap[v.PackageType] = list
		}
	}
	for _, v := range productName {
		child, ok := SAPackageMap[v]
		if !ok {
			continue
		}
		var helper cvesa.SAPackageHelper
		helper.ProductName = v
		helper.Child = child
		SAPackages = append(SAPackages, helper)
	}
	return SAPackages
}

func reReference(datas []models.CveSecurityNoticeReference) []models.RCveSecurityNoticeReference {
	var list = make([]models.RCveSecurityNoticeReference, 0, len(datas))
	for _, v := range datas {
		list = append(list, models.RCveSecurityNoticeReference{CveSecurityNoticeReference: v, Updateime: v.Updateime.Format(_const.Format)})
	}
	return list
}

func FindAllAffectedProduct() []string {
	products := dao.DefaultSecurityNotice.FindAllAffectedProduct()

	productSet := sets.NewString()
	for _, v := range products {
		for _, product := range strings.Split(v, ";") {
			if product == "" {
				continue
			}

			productSet.Insert(product)
		}
	}

	t := productSet.UnsortedList()
	sort.Strings(t)

	return t
}

func FindAllAffectedComponent(securityLevel, affectedProduct []string, noticeType string) []string {
	return dao.DefaultSecurityNotice.FindAllAffectedComponent(securityLevel, affectedProduct, noticeType)
}

func MaxNoticeId(noticeType string) (string, error) {
	return dao.DefaultSecurityNotice.MaxNoticeId(noticeType)
}

func PublishedBugs() (bugs []string, err error) {
	notices, err := dao.DefaultSecurityNotice.FindAllSecurityNotice(_const.NoticeTypeBug)
	if err != nil {
		return
	}

	for _, row := range notices {
		cveId := strings.Split(strings.Trim(row.CveId, ";"), ";")
		for _, v := range cveId {
			split := strings.Split(v, "-")
			bugs = append(bugs, split[len(split)-1])
		}
	}

	return
}
