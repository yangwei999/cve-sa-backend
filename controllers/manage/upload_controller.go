package controllers

import (
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strings"

	"cve-sa-backend/dao"
	"cve-sa-backend/handles/manage"
	"cve-sa-backend/iniconf"
	"cve-sa-backend/models"
	"cve-sa-backend/utils"
	"cve-sa-backend/utils/tools"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
)

func Refresh(c *gin.Context) {
	var id = int64(0)
	var limit = int64(100)
	f := c.Query("flag")
	var err error
	go func() {
		for f == "1" {
			var cveProducts []models.CveProductPackage
			err = iniconf.DB.Raw("select * from cve_product_package where id > ? limit ?", id, limit).Find(&cveProducts).Error
			if err != nil || len(cveProducts) == 0 {
				break
			}

			for _, v := range cveProducts {
				id = v.Id
				v.CreateTime = v.Updateime
				dao.DefaultCveProductPackage.UpdateSec(&v)
			}
		}

		for f == "2" {
			var cveDatabase []models.CveDatabase
			err = iniconf.DB.Raw("select * from cve_database where id > ? limit ?", id, limit).Find(&cveDatabase).Error
			if err != nil || len(cveDatabase) == 0 {
				break
			}

			for _, v := range cveDatabase {
				id = v.Id
				v.CreateTime = v.Updateime
				iniconf.DB.Updates(&v)
			}
		}
		return
	}()
	tools.Success(c, "success")
}
func DeleteCVE(c *gin.Context) {
	cveId := c.PostForm("deleteCVEID")
	packageName := c.PostForm("packageName")

	if cveId == "" {
		tools.Failure(c, "cve is empty, please enter cve number.")
		return
	}
	cveId = strings.TrimSpace(cveId)
	packageName = strings.TrimSpace(packageName)

	result, err := manage.DeleteCVE(cveId, packageName)
	if err != nil {
		iniconf.Log.Error("delete cve error", zap.String("error", err.Error()))
		tools.Failure(c, err.Error())
		return
	}
	tools.Success(c, result)
}

func DeleteSA(c *gin.Context) {
	saNo := c.PostForm("deleteSAID")
	if saNo == "" {
		tools.Failure(c, "security number is empty, please enter security number.")
		return
	}

	saNo = strings.TrimSpace(saNo)
	err := manage.DeleteSA(saNo)
	if err != nil {
		iniconf.Log.Error("deleteCVE errors", zap.Error(err))
		tools.Failure(c, err.Error())
		return
	}
	tools.Success(c, "success")
}

func GetHttpParserBeanListByCve(c *gin.Context) {
	cve := c.PostForm("cveNo")
	packageName := c.PostForm("packageName")
	if cve == "" {
		tools.Failure(c, "cve number is empty, please input cve number")
		return
	}

	cve = strings.TrimSpace(cve)
	packageName = strings.TrimSpace(packageName)
	result, err := manage.GetHttpParserBeanListByCve(cve, packageName)
	if err != nil {
		iniconf.Log.Error("manage.GetHttpParserBeanListByCve error", zap.Error(err), zap.String("cve", cve), zap.String("packageName", packageName))
		tools.Failure(c, "GetHttpParserBeanListByCve failed. An exception occurred. err: "+err.Error())
		return
	}

	tools.Success(c, result)
}

func SyncCve(c *gin.Context) {
	cveFileName := c.PostForm("cveNo")

	if cveFileName == "" {
		c.JSON(http.StatusOK, "the cve file is empty, please enter file path")
		return
	}
	cveFileName = strings.TrimSpace(cveFileName)

	if !strings.HasSuffix(cveFileName, ".xml") && !strings.HasSuffix(cveFileName, ".XML") {
		cveFileName += ".xml"
	}

	result, err := manage.SyncCve(cveFileName)
	if err != nil {
		iniconf.Log.Error("manage.SyncCve error:", zap.Error(err))
		tools.Failure(c, result)
		return
	}
	tools.Success(c, result)
}

func SyncHardwareCompatibility(c *gin.Context) {
	result, err := manage.SyncHardwareCompatibility()
	if err != nil {
		iniconf.SLog.Error("syncHardwareCompatibility failed :", err)
		tools.Failure(c, "syncHardwareCompatibility failed. An exception occurred."+err.Error())
		return
	}
	tools.Success(c, result)
}

func SyncDriverCompatibility(c *gin.Context) {
	result, err := manage.SyncDriverCompatibility()
	if err != nil {
		iniconf.SLog.Error("syncHardwareCompatibility failed :", err)
		tools.Failure(c, "syncHardwareCompatibility failed. An exception occurred."+err.Error())
		return
	}
	tools.Success(c, result)
}

func TransferOldData(c *gin.Context) {
	cve := c.PostForm("saNo")
	if cve == "" {
		tools.Failure(c, "SA is null. Please input SA.")
		return
	}
	cve = strings.TrimSpace(cve)
	result, err := manage.TransferData(cve)
	if err != nil {
		iniconf.SLog.Error("transferOldData failed,", err)
		tools.Failure(c, "transferOldData failed. An exception occurred. err: "+err.Error())
		return
	}
	tools.Success(c, result)
}

func SyncSA(c *gin.Context) {
	saFileName := c.PostForm("saNo")
	if saFileName == "" {
		tools.Failure(c, "security file is empty, please enter file path")
		return
	}
	saFileName = strings.TrimSpace(saFileName)
	if !strings.HasSuffix(saFileName, ".xml") && !strings.HasSuffix(saFileName, ".XML") {
		saFileName += ".xml"
	}

	result, err := manage.SyncSA(saFileName)
	if err != nil {
		iniconf.SLog.Error("SyncSA failed,", err)
		tools.Failure(c, result)
		return
	}
	tools.Success(c, result)
}

func SyncAll(c *gin.Context) {
	result, err := manage.SyncAll()

	if err != nil {
		iniconf.SLog.Error("SyncAll failed,", err)
		tools.Failure(c, result+err.Error())
		return
	}

	tools.Success(c, result)
}

func SyncOsv(c *gin.Context) {
	result, err := manage.SyncOsv()
	if err != nil {
		iniconf.SLog.Error("syncOsv failed :", err)
		tools.Failure(c, "syncOsv failed. An exception occurred."+err.Error())
		return
	}
	tools.Success(c, result)
}

func GenerateXml(c *gin.Context) {
	startTime := c.PostForm("startTime")
	if startTime == "" {
		tools.Failure(c, "startTime is null. Please input startTime.")
		return
	}
	rt := regexp.MustCompile(`^(\d{4})-\d{2}-(\d{2})$`)
	find := rt.Match([]byte(startTime))
	if !find {
		tools.Failure(c, `Error: please enter the correct start time in a format like this "yyyy-MM-dd".`)
		return
	}
	secLinkConfig := "https://cvemanager.test.osinfra.cn/v1/download/excel/triggerUnaffectedCve?startTime=%s"
	resp, err := http.Get(fmt.Sprintf(secLinkConfig, startTime))
	if err != nil {
		iniconf.SLog.Error("generateXml is failed,err :", err)
		tools.Failure(c, err)
		return
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		iniconf.SLog.Error("generateXml is failed,err :", err)
		tools.Failure(c, err)
		return
	}
	tools.Success(c, string(body))
}

func InspectionXml(c *gin.Context) {
	fileName := c.PostForm("fileName")
	if fileName == "" {
		tools.Failure(c, "fileName is null. Please input fileName.")
		return
	}

	bys, err := utils.DownloadFile(iniconf.Obs.DownloadUpdateinfo + fileName)
	if err != nil {
		tools.Failure(c, err)
		return
	}

	var u utils.Updates
	err = xml.Unmarshal(bys, &u)
	if err != nil {
		tools.Failure(c, err)
		return
	}
	tools.Success(c, "success")
}

func SyncDisclosure(c *gin.Context) {
	err := manage.SyncDisclosure()
	if err != nil {
		iniconf.SLog.Error("SyncDisclosure failed :", err)
		tools.Failure(c, err)
		return
	}
	manage.SendMsgForCveManager("import")
	tools.Success(c, "success")
}

func Disclosure(c *gin.Context) {
	fileName := c.Query("fileName")

	err := manage.Disclosure(fileName)
	if err != nil {
		tools.Failure(c, err)
		return
	}

	tools.Success(c, "success")
}

func Import(c *gin.Context) {
	flag := c.PostForm("K")
	manage.SendMsgForCveManager(flag)
	tools.Success(c, "success")
}

func SyncFile(c *gin.Context) {
	err := manage.Sync(c.PostForm("id"), strings.Split(c.PostForm("branch"), ","))
	if err != nil {
		tools.Failure(c, err)
		return
	}

	tools.Success(c, "success")
}
